package crypto

import (
	"encoding/base64"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

// RC4 test data generated by Go crypto/rc4 library
// Key sizes: 1-256 bytes
// All data is base64 encoded

// Test case 1: Basic RC4 encryption with 16-byte key
// Key size: 16 bytes
var rc4Test1 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"MTIzNDU2Nzg5MDEyMzQ1Ng==",
	"aGVsbG8gd29ybGQ=",
	"SNX/3UvFu+ZhrXs=",
}

// Test case 2: RC4 encryption with 24-byte key
// Key size: 24 bytes
var rc4Test2 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0",
	"aGVsbG8gd29ybGQ=",
	"3aUH+NB+Fmm/T+o=",
}

// Test case 3: RC4 encryption with 32-byte key
// Key size: 32 bytes
var rc4Test3 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=",
	"aGVsbG8gd29ybGQ=",
	"CZDqbmeHKxkMW7I=",
}

// Test case 4: RC4 encryption with empty plaintext
// Key size: 7 bytes
var rc4Test4 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"dGVzdGtleQ==",
	"",
	"",
}

// Test case 5: RC4 encryption with long plaintext
// Key size: 8 bytes
var rc4Test5 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"bXlzZWNyZXQ=",
	"VGhpcyBpcyBhIGxvbmdlciBwbGFpbnRleHQgdGhhdCB3aWxsIGJlIGVuY3J5cHRlZCB1c2luZyBSQzQgYWxnb3JpdGhtLiBJdCBjb250YWlucyBtdWx0aXBsZSBzZW50ZW5jZXMgYW5kIHZhcmlvdXMgY2hhcmFjdGVycy4=",
	"wnIw+R2dZ50CzieiJb2Okusn5iis6/jctzxYQ4gBV4flw8uG8AAACafSTrn2hYzFLWs/nLcGrnfCsG8/7kV3GypT22SkHHA3boSALzbbK0I2qibh4/9UnVeFVBq0zwDMYeG+NVU1uY8oMU6zDcwXpVyy8Hpg24rn+XaZgOw=",
}

// Test case 6: RC4 encryption with Unicode text
// Key size: 7 bytes
var rc4Test6 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"dW5pY29kZQ==",
	"SGVsbG8sIOS4lueVjCEg8J+MjQ==",
	"IwCiuIECmM10Xm8ybGNHHxgQqw==",
}

// Test case 7: RC4 encryption with binary data
// Key size: 6 bytes
var rc4Test7 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"YmluYXJ5",
	"AAECAwQFBgcICQoLDA0ODw==",
	"AZTSUjDm41+keKdWESgj5w==",
}

// Test case 8: RC4 encryption with special characters
// Key size: 7 bytes
var rc4Test8 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"c3BlY2lhbA==",
	"U3BlY2lhbCBjaGFyczogQCMkJV4mKigpXystPVtde318Oyc6IiwuLzw+Pw==",
	"CE81T31vmJaaeK9ASirGeGcoa/bS2BUSX0PZ+pTrsKUIl9dtScNBbqUQhA==",
}

// Test case 9: RC4 encryption with minimum key size (1 byte)
// Key size: 1 bytes
var rc4Test9 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"YQ==",
	"dGVzdA==",
	"ZNnrag==",
}

// Test case 10: RC4 encryption with maximum key size (256 bytes)
// Key size: 256 bytes
var rc4Test10 = struct {
	key        string
	plaintext  string
	ciphertext string
}{
	"AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==",
	"bWF4aW11bSBrZXkgc2l6ZSB0ZXN0",
	"M0/P22Dz628YtuT5LzNvQPVtYKrS",
}

// TestRC4Examples tests RC4 encryption with various key sizes and plaintexts
func TestRC4Examples(t *testing.T) {
	tests := []struct {
		name     string
		testData struct {
			key        string
			plaintext  string
			ciphertext string
		}
		hasOutput bool // Whether this test has deterministic output
	}{
		{
			name:      "Basic RC4 encryption with 16-byte key",
			testData:  rc4Test1,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with 24-byte key",
			testData:  rc4Test2,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with 32-byte key",
			testData:  rc4Test3,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with empty plaintext",
			testData:  rc4Test4,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with long plaintext",
			testData:  rc4Test5,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with Unicode text",
			testData:  rc4Test6,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with binary data",
			testData:  rc4Test7,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with special characters",
			testData:  rc4Test8,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with minimum key size (1 byte)",
			testData:  rc4Test9,
			hasOutput: true,
		},
		{
			name:      "RC4 encryption with maximum key size (256 bytes)",
			testData:  rc4Test10,
			hasOutput: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Decode test data
			key, _ := base64.StdEncoding.DecodeString(tt.testData.key)
			plaintext, _ := base64.StdEncoding.DecodeString(tt.testData.plaintext)
			expectedCiphertext, _ := base64.StdEncoding.DecodeString(tt.testData.ciphertext)

			// Test encryption
			enc := NewEncrypter().FromBytes(plaintext).ByRc4(key)
			assert.Nil(t, enc.Error)
			if len(plaintext) > 0 {
				assert.NotEmpty(t, enc.dst)
			} else {
				assert.Empty(t, enc.dst)
			}

			// For tests with deterministic output, verify against expected values
			if tt.hasOutput {
				if len(plaintext) > 0 {
					assert.Equal(t, expectedCiphertext, enc.dst)
					assert.Equal(t, tt.testData.ciphertext, base64.StdEncoding.EncodeToString(enc.dst))
				} else {
					// For empty input, both expected and actual should be empty
					assert.Empty(t, enc.dst)
				}
			}

			// Test decryption
			dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
			assert.Nil(t, dec.Error)
			assert.Equal(t, plaintext, dec.ToBytes())
		})
	}
}

// TestRC4ExampleKeySizes tests RC4 encryption with different key sizes
func TestRC4ExampleKeySizes(t *testing.T) {
	tests := []struct {
		name      string
		key       []byte
		plaintext string
	}{
		{
			name:      "RC4 with 16-byte key",
			key:       []byte("1234567890123456"),
			plaintext: "hello world",
		},
		{
			name:      "RC4 with 24-byte key",
			key:       []byte("123456789012345678901234"),
			plaintext: "hello world",
		},
		{
			name:      "RC4 with 32-byte key",
			key:       []byte("12345678901234567890123456789012"),
			plaintext: "hello world",
		},
		{
			name:      "RC4 with 1-byte key",
			key:       []byte("a"),
			plaintext: "test",
		},
		{
			name:      "RC4 with 256-byte key",
			key:       make([]byte, 256),
			plaintext: "maximum key size test",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Initialize 256-byte key with sequential values
			if len(tt.key) == 256 {
				for i := range tt.key {
					tt.key[i] = byte(i)
				}
			}

			// Test encryption
			enc := NewEncrypter().FromString(tt.plaintext).ByRc4(tt.key)
			assert.Nil(t, enc.Error)
			assert.NotEmpty(t, enc.dst)

			// Test decryption
			dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(tt.key)
			assert.Nil(t, dec.Error)
			assert.Equal(t, tt.plaintext, dec.ToString())
		})
	}
}

// TestRC4ExampleInputTypes tests RC4 encryption with different input types
func TestRC4ExampleInputTypes(t *testing.T) {
	key := []byte("testkey123456789")

	t.Run("string input", func(t *testing.T) {
		plaintext := "Hello, RC4!"

		enc := NewEncrypter().FromString(plaintext).ByRc4(key)
		assert.Nil(t, enc.Error)
		assert.NotEmpty(t, enc.dst)

		dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
		assert.Nil(t, dec.Error)
		assert.Equal(t, plaintext, dec.ToString())
	})

	t.Run("bytes input", func(t *testing.T) {
		plaintext := []byte("Hello, RC4!")

		enc := NewEncrypter().FromBytes(plaintext).ByRc4(key)
		assert.Nil(t, enc.Error)
		assert.NotEmpty(t, enc.dst)

		dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
		assert.Nil(t, dec.Error)
		assert.Equal(t, plaintext, dec.ToBytes())
	})

	t.Run("empty input", func(t *testing.T) {
		plaintext := ""

		enc := NewEncrypter().FromString(plaintext).ByRc4(key)
		assert.Nil(t, enc.Error)
		assert.Empty(t, enc.dst)

		dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
		assert.Nil(t, dec.Error)
		assert.Equal(t, plaintext, dec.ToString())
	})

	t.Run("streaming mode", func(t *testing.T) {
		plaintext := "Hello, RC4 streaming!"

		// Test streaming encryption
		enc := NewEncrypter().FromString(plaintext).ByRc4(key)
		assert.Nil(t, enc.Error)
		assert.NotEmpty(t, enc.dst)

		// Test streaming decryption
		dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
		assert.Nil(t, dec.Error)
		assert.Equal(t, plaintext, dec.ToString())
	})
}

// Example functions for documentation
func ExampleEncrypter_ByRc4() {
	key := []byte("1234567890123456")
	plain := "hello world"
	enc := NewEncrypter().FromString(plain).ByRc4(key)
	fmt.Println(base64.StdEncoding.EncodeToString(enc.dst))
	// Output: SNX/3UvFu+ZhrXs=
}

func ExampleEncrypter_ByRc4_long_key() {
	key := []byte("12345678901234567890123456789012")
	plain := "hello world"
	enc := NewEncrypter().FromString(plain).ByRc4(key)
	fmt.Println(base64.StdEncoding.EncodeToString(enc.dst))
	// Output: CZDqbmeHKxkMW7I=
}

func ExampleEncrypter_ByRc4_empty() {
	key := []byte("testkey")
	plain := ""
	enc := NewEncrypter().FromString(plain).ByRc4(key)
	fmt.Println("Encrypted length:", len(enc.dst))
	// Output: Encrypted length: 0
}

func ExampleDecrypter_ByRc4() {
	key := []byte("1234567890123456")
	plain := "hello world"

	// Encrypt
	enc := NewEncrypter().FromString(plain).ByRc4(key)

	// Decrypt
	dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
	fmt.Println(dec.ToString())
	// Output: hello world
}

func ExampleDecrypter_ByRc4_unicode() {
	key := []byte("unicode")
	plain := "Hello, ‰∏ñÁïå! üåç"

	// Encrypt
	enc := NewEncrypter().FromString(plain).ByRc4(key)

	// Decrypt
	dec := NewDecrypter().FromRawBytes(enc.dst).ByRc4(key)
	fmt.Println(dec.ToString())
	// Output: Hello, ‰∏ñÁïå! üåç
}
